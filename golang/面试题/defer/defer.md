golang defer是如何实现的，底层数据机构都有哪些


Go 语言中的 `defer` 是一种用于延迟执行的机制，允许在函数返回之前执行某些代码。它的实现依赖于 Go 运行时（runtime）和一些底层的数据结构。以下是关于 `defer` 的实现细节以及其底层数据结构的详细说明。

---

### **1. Defer 的工作原理**

#### (1) **延迟调用栈**
- 每次调用 `defer` 时，Go 会将该延迟调用的相关信息存储到一个栈中。
- 当函数即将返回时，Go 会从栈顶依次弹出这些延迟调用并执行。

#### (2) **执行顺序**
- `defer` 的执行顺序是**后进先出（LIFO）**，即最后声明的 `defer` 语句会最先执行。

#### (3) **与异常处理的关系**
- 在 Go 中，`defer` 常用于资源清理、错误处理等场景。
- 如果函数中发生了 panic，`defer` 仍然会在 panic 被恢复之前执行。

---

### **2. Defer 的底层实现**

#### (1) **核心数据结构：_defer 结构体**
Go 的运行时使用 `_defer` 结构体来存储每个延迟调用的信息。以下是 `_defer` 的主要字段：

```go
type _defer struct {
    siz     int32          // 参数大小（字节）
    started bool           // 是否已经开始执行
    sp      uintptr        // 延迟调用发生时的栈指针
    pc      uintptr        // 延迟调用发生时的程序计数器
    fn      *funcval       // 延迟调用的函数指针
    args    unsafe.Pointer // 延迟调用的参数
    frame   unsafe.Pointer // 延迟调用的栈帧
    link    *_defer        // 指向下一个 _defer 结构体的指针（形成链表）
}
```

- **siz**：延迟调用的参数大小。
- **started**：标记延迟调用是否已经开始执行。
- **sp** 和 **pc**：记录延迟调用发生时的栈指针和程序计数器，用于调试和错误处理。
- **fn**：指向延迟调用的函数。
- **args**：延迟调用的参数。
- **frame**：延迟调用的栈帧。
- **link**：指向下一个 `_defer` 结构体的指针，形成一个链表。

#### (2) **延迟调用栈**
- 每个 Goroutine 都维护了一个 `_defer` 链表，用于存储当前 Goroutine 中的所有延迟调用。
- 当调用 `defer` 时，新的 `_defer` 结构体会被添加到链表头部。
- 当函数返回时，Go 会从链表头部依次弹出 `_defer` 并执行。

---

### **3. Defer 的执行流程**

#### (1) **声明阶段**
- 当遇到 `defer` 语句时：
    1. 创建一个新的 `_defer` 结构体。
    2. 将延迟调用的函数和参数存储到 `_defer` 中。
    3. 将 `_defer` 添加到当前 Goroutine 的 `_defer` 链表头部。

#### (2) **执行阶段**
- 当函数即将返回时：
    1. 从 `_defer` 链表头部依次取出 `_defer` 结构体。
    2. 执行 `_defer` 中的延迟调用。
    3. 删除已执行的 `_defer` 结构体。

#### (3) **Panic 处理**
- 如果函数中发生了 panic：
    1. 所有已注册的 `defer` 仍然会被执行。
    2. 在所有 `defer` 执行完毕后，panic 继续传播。

---

### **4. 示例代码**

以下是一个简单的示例，展示 `defer` 的执行顺序及其底层行为：

```go
package main

import "fmt"

func main() {
    fmt.Println("Start")
    defer fmt.Println("Defer 1")
    defer fmt.Println("Defer 2")
    fmt.Println("End")
}
```

**输出**：
```
Start
End
Defer 2
Defer 1
```

**解释**：
- `defer fmt.Println("Defer 1")` 和 `defer fmt.Println("Defer 2")` 的 `_defer` 结构体会依次被添加到链表头部。
- 当函数返回时，链表中的 `_defer` 会按照 LIFO 的顺序执行。

---

### **5. 底层数据结构的作用**

#### (1) **_defer 链表**
- `_defer` 链表用于存储当前 Goroutine 中的所有延迟调用。
- 它是一个单向链表，通过 `link` 字段连接各个 `_defer` 结构体。

#### (2) **Goroutine 的状态管理**
- 每个 Goroutine 都有自己的 `_defer` 链表。
- 当 Goroutine 被调度时，Go 运行时会检查是否存在未执行的 `defer`，并在适当的时候执行它们。

#### (3) **栈管理**
- `_defer` 结构体中的 `sp` 和 `frame` 字段用于记录延迟调用发生时的栈信息。
- 这有助于在调试或错误处理时定位问题。

---

### **6. Defer 的性能开销**

虽然 `defer` 提供了简洁的语法和强大的功能，但它也带来了一定的性能开销：
- 每次调用 `defer` 都需要分配和管理 `_defer` 结构体。
- 函数返回时需要遍历 `_defer` 链表并执行延迟调用。

因此，在性能敏感的场景中，应谨慎使用 `defer`。

---

### **7. 总结**

- **Defer 的实现**基于 Go 运行时的 `_defer` 链表，每次调用 `defer` 时都会创建一个新的 `_defer` 结构体并将其添加到链表头部。
- **执行顺序**是后进先出（LIFO），即最后声明的 `defer` 语句会最先执行。
- **底层数据结构**包括 `_defer` 结构体和 `_defer` 链表，用于存储和管理延迟调用的信息。
- **应用场景**包括资源清理、错误处理、日志记录等。

通过理解 `defer` 的底层实现，你可以更好地掌握其工作机制，并在实际开发中合理使用它。